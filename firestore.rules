rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner() {
      return isSignedIn() && resource.data.organizerId == request.auth.uid;
    }

    function isCreatingOwner() {
      return isSignedIn() && request.resource.data.organizerId == request.auth.uid;
    }

    function nonEmptyString(field) {
      return (field is string) && field.size() > 0 && field.size() <= 2000;
    }

    function validStatus(s) {
      return s in ["active", "draft", "archived"];
    }

    function validVisibility(v) {
      return v in ["public", "private"];
    }

    function isPublicActive() {
      return resource.data.status == "active" && resource.data.visibility == "public";
    }

    // Allow only these fields in retreat documents (prevents junk/unexpected fields)
    function retreatAllowedKeys() {
      return [
        "title",
        "subtitle",
        "description",
        "location",
        "startDate",
        "endDate",
        "price",
        "imageUrl",
        "organizerId",
        "organizerName",
        "status",
        "visibility",
        "createdAt",
        "updatedAt"
      ];
    }

    match /retreats/{retreatId} {

      // READ:
      // - Everyone can read only active+public retreats
      // - Owner can read their own retreats (including draft/private)
      allow get, list: if isPublicActive() || isOwner();

      // CREATE:
      // - Only signed-in users
      // - organizerId must be auth.uid
      // - validate main fields
      // - status/visibility must be valid
      // - limit fields to allowed keys
      allow create: if isCreatingOwner()
        && request.resource.data.keys().hasOnly(retreatAllowedKeys())
        && nonEmptyString(request.resource.data.title)
        && nonEmptyString(request.resource.data.description)
        && nonEmptyString(request.resource.data.location)
        // startDate/endDate can be string OR timestamp (accept both)
        && (
          (request.resource.data.startDate is string && request.resource.data.startDate.size() > 0) ||
          (request.resource.data.startDate is timestamp)
        )
        && (
          (request.resource.data.endDate is string && request.resource.data.endDate.size() > 0) ||
          (request.resource.data.endDate is timestamp)
        )
        && validStatus(request.resource.data.status)
        && validVisibility(request.resource.data.visibility);

      // UPDATE:
      // - Only owner
      // - organizerId cannot be changed
      // - validate status/visibility (if present)
      // - keep keys restricted
      allow update: if isOwner()
        && request.resource.data.keys().hasOnly(retreatAllowedKeys())
        && request.resource.data.organizerId == resource.data.organizerId
        && nonEmptyString(request.resource.data.title)
        && nonEmptyString(request.resource.data.description)
        && nonEmptyString(request.resource.data.location)
        && (
          (request.resource.data.startDate is string && request.resource.data.startDate.size() > 0) ||
          (request.resource.data.startDate is timestamp)
        )
        && (
          (request.resource.data.endDate is string && request.resource.data.endDate.size() > 0) ||
          (request.resource.data.endDate is timestamp)
        )
        && validStatus(request.resource.data.status)
        && validVisibility(request.resource.data.visibility);

      // DELETE:
      // - Only owner
      allow delete: if isOwner();
    }

    // (Optional) Lock down everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
